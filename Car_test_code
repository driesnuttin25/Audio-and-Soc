/*
 * made by: Dries Nuttin
 *
 * Welcome to my project for PXL-Digital System on chip
 * This project includes both code for the HC-SR04 ultrasonic sensor,
 * a joyit speed sensor and PWM signals for motor control.
 */


/* -----------------------------------------------
 * | ULTRASOON                                    |
 * ----------------------------------------------*/

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "ultrasoon.h"
#include "sleep.h"

int main()
{
    init_platform();
    unsigned int distance0;
    unsigned int distance1;
    print("HC_SR04 Test code in centimeters:\n");
    print("=======================\n\r");

    for(;;){
    	sleep_A9(1);
    	distance0 = ULTRASOON_mReadReg(XPAR_ULTRASOON_0_S00_AXI_BASEADDR,ULTRASOON_S00_AXI_SLV_REG2_OFFSET);
    	distance1 = ULTRASOON_mReadReg(XPAR_ULTRASOON_1_S00_AXI_BASEADDR,ULTRASOON_S00_AXI_SLV_REG2_OFFSET);
    	printf("Distance 1 = %d cm\n\r",distance0);
    	printf("Distance 2 = %d cm\n\r",distance1);
    	printf("\n\r");
    }


    cleanup_platform();
    return 0;
}





/* -----------------------------------------------
 * | SPEED SENSOR 		                          |
 * ----------------------------------------------*/

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "sleep.h"
#include "speed_sensor.h"

int main()
{
    init_platform();
    unsigned int value_1 = 0;
    unsigned int value_2 = 0;
    print("Speed Sensor test \n\r");
	SPEED_SENSOR_mWriteReg(XPAR_SPEED_SENSOR_0_S00_AXI_BASEADDR,SPEED_SENSOR_S00_AXI_SLV_REG1_OFFSET,0b1111);
	SPEED_SENSOR_mWriteReg(XPAR_SPEED_SENSOR_1_S00_AXI_BASEADDR,SPEED_SENSOR_S00_AXI_SLV_REG1_OFFSET,0b1111);


    for(;;)
    {
    	sleep_A9(1);
    	value_1 = SPEED_SENSOR_mReadReg(XPAR_SPEED_SENSOR_0_S00_AXI_BASEADDR,SPEED_SENSOR_S00_AXI_SLV_REG2_OFFSET);
    	value_2 = SPEED_SENSOR_mReadReg(XPAR_SPEED_SENSOR_1_S00_AXI_BASEADDR,SPEED_SENSOR_S00_AXI_SLV_REG2_OFFSET);

        printf("Pulses 2: [%d]\n\r",value_1);
        printf("Pulses 1: [%d]\n\r\n\r",value_2);
    }
    cleanup_platform();
    return 0;
}





/* -----------------------------------------------
 * | MOTOR CONTROL                                |
 * ----------------------------------------------*/


#include "xparameters.h"
#include "xtmrctr.h"
#include "xscugic.h"
#include "xil_exception.h"
#include "xil_printf.h"
#include "platform.h"

// Definitions
#define SCUGIC_DEVICE_ID        XPAR_SCUGIC_SINGLE_DEVICE_ID
#define AXI_TIMER_DEVICE_ID     XPAR_AXI_TIMER_0_DEVICE_ID
#define AXI_TIMER_IRPT_INTR     XPAR_FABRIC_AXI_TIMER_0_INTERRUPT_INTR

#define AXI_TIMER_CHANNEL_1     0
#define AXI_TIMER_CHANNEL_2     1

#define AXI_TIMER_PERIOD_US     10000
#define AXI_TIMER_PWM_HIGH_TIME_US 2000

XTmrCtr TimerInstance;
XScuGic IntcInstance;

void TimerInterruptHandler(void *CallBackRef, u8 TmrCtrNumber) {
    XTmrCtr *InstancePtr = (XTmrCtr *)CallBackRef;
    xil_printf("AXI Timer Int! Channel: %d\n", TmrCtrNumber + 1);
}

u32 US_To_RegValue(u32 US) {
    return 0xFFFFFFFF - (50 * US);
}

u32 US_To_NS(u32 US) {
    return US * 1000;
}

int InitializeTimer(XTmrCtr *TimerPtr, u32 DeviceId) {
    int Status, DutyCycle;

    Status = XTmrCtr_Initialize(TimerPtr, DeviceId);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    Status = XTmrCtr_SelfTest(TimerPtr, 1);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XTmrCtr_SetHandler(TimerPtr, TimerInterruptHandler, TimerPtr);
    XTmrCtr_SetResetValue(TimerPtr, AXI_TIMER_CHANNEL_1, US_To_RegValue(AXI_TIMER_PERIOD_US));
    XTmrCtr_SetResetValue(TimerPtr, AXI_TIMER_CHANNEL_2, US_To_RegValue(AXI_TIMER_PERIOD_US));
    XTmrCtr_SetOptions(TimerPtr, AXI_TIMER_CHANNEL_1, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION);
    XTmrCtr_SetOptions(TimerPtr, AXI_TIMER_CHANNEL_2, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION);

    DutyCycle = XTmrCtr_PwmConfigure(TimerPtr, US_To_NS(AXI_TIMER_PERIOD_US), US_To_NS(AXI_TIMER_PWM_HIGH_TIME_US));
    xil_printf("AXI Timer PWM DutyCycle: %d%%!\n", DutyCycle);

    return XST_SUCCESS;
}

int InitializeInterruptSystem(XScuGic *IntcPtr, XTmrCtr *TimerPtr) {
    int Status;
    XScuGic_Config *IntcConfig;

    IntcConfig = XScuGic_LookupConfig(SCUGIC_DEVICE_ID);
    if (IntcConfig == NULL) return XST_FAILURE;

    Status = XScuGic_CfgInitialize(IntcPtr, IntcConfig, IntcConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, IntcPtr);
    Xil_ExceptionEnable();

    Status = XScuGic_Connect(IntcPtr, AXI_TIMER_IRPT_INTR, (Xil_ExceptionHandler)TimerInterruptHandler, TimerPtr);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XScuGic_Enable(IntcPtr, AXI_TIMER_IRPT_INTR);

    return XST_SUCCESS;
}

int main() {
    xil_printf("AXI Timer and PWM Test!\n");
    init_platform();

    if (InitializeTimer(&TimerInstance, AXI_TIMER_DEVICE_ID) != XST_SUCCESS) {
        xil_printf("AXI Timer Initialization Failed!\n");
        return XST_FAILURE;
    }

    if (InitializeInterruptSystem(&IntcInstance, &TimerInstance) != XST_SUCCESS) {
        xil_printf("GIC Initialization Failed!\n");
        return XST_FAILURE;
    }

    XTmrCtr_Start(&TimerInstance, AXI_TIMER_CHANNEL_1);
    XTmrCtr_Start(&TimerInstance, AXI_TIMER_CHANNEL_2);

    XTmrCtr_PwmEnable(&TimerInstance);

    xil_printf("Entering Main Loop\n");
    while (1) {
        usleep(1000000);  // 1 second delay
    }

    cleanup_platform();
    return 0;
}

